<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machine Head Offline Database</title>
    <style>
        body { font-family: Arial, sans-serif; }
        table { border-collapse: collapse; width: 100%; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        button, input, select, textarea { margin: 10px 0; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: white; margin: 15% auto; padding: 20px; width: 80%; max-width: 500px; }
        .close { float: right; cursor: pointer; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
</head>
<body>
    <h1>Machine Head Offline Database</h1>
    
    <section>
        <h2>Import and Export</h2>
        <input type="file" id="jsonUpload" accept=".json">
        <button id="exportJSON">Export All Data as JSON</button>
        <button id="clearData">Clear Database</button>
        <button id="exportPDF">Export Filtered Data as PDF</button>
    </section>
    
    <section>
        <h2>Add to Log</h2>
        <form id="addLogForm">
            <label>Line: <input type="text" id="addLine" required></label><br>
            <label>Date: <input type="date" id="addDate" required></label><br>
            <label>Head: <input type="number" id="addHead" min="1" max="14" required></label><br>
            <label>Offline Status: 
                <select id="addOffline">
                    <option>Active</option>
                    <option>Offline</option>
                </select>
            </label><br>
            <label>Issue: 
                <select id="addIssue">
                    <option>None</option>
                    <option>Operator</option>
                    <option>Chute</option>
                    <option>Installed Wrong</option>
                    <option>Detached Head</option>
                    <option>Hopper Issues</option>
                    <option>Stepper Motor Error</option>
                    <option>Load Cell</option>
                    <option>Other</option>
                </select>
            </label><br>
            <label>Repaired: 
                <select id="addRepaired">
                    <option>Fixed</option>
                    <option>Not Fixed</option>
                    <option>N/A</option>
                </select>
            </label><br>
            <label>Notes: <textarea id="addNotes"></textarea></label><br>
            <label>Machine Notes: <textarea id="addMachineNotes"></textarea></label><br>
            <button type="submit">Add Log Entry</button>
        </form>
    </section>
    
    <section>
        <h2>Filter and View Offline Heads and Machine Notes</h2>
        <label>Filter by Date: <select id="filterDate"><option value="">All Dates</option></select></label>
        <label>Filter by Line: <select id="filterLine"><option value="">All Lines</option></select></label>
        <label>Filter by Head: <select id="filterHead"><option value="">All Heads</option></select></label>
        <label>Filter by Issue: <select id="filterIssue"><option value="">All Issues</option></select></label>
        <label>Sort by: 
            <select id="sortBy">
                <option>Date</option>
                <option>Line</option>
                <option>Both (Date then Line)</option>
            </select>
        </label>
        <label>Order: 
            <select id="sortOrder">
                <option>Descending</option>
                <option>Ascending</option>
            </select>
        </label>
        <button id="applyFilters">Apply Filters and Sort</button>
        <table>
            <thead>
                <tr>
                    <th>Date</th>
                    <th>Line</th>
                    <th>Head</th>
                    <th>Issue (Reasoning)</th>
                    <th>Repaired</th>
                    <th>Notes</th>
                    <th>Machine Notes</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="historyBody"></tbody>
        </table>
    </section>

    <!-- Edit Modal -->
    <div id="editModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Edit Entry</h2>
            <form id="editForm">
                <label>Line: <input type="text" id="editLine" required></label><br>
                <label>Date: <input type="date" id="editDate" required></label><br>
                <label>Head: <input type="text" id="editHead" readonly></label><br>
                <label>Offline Status: 
                    <select id="editOffline">
                        <option>Active</option>
                        <option>Offline</option>
                    </select>
                </label><br>
                <label>Issue: 
                    <select id="editIssue">
                        <option>None</option>
                        <option>Operator</option>
                        <option>Chute</option>
                        <option>Installed Wrong</option>
                        <option>Detached Head</option>
                        <option>Hopper Issues</option>
                        <option>Stepper Motor Error</option>
                        <option>Load Cell</option>
                        <option>Other</option>
                    </select>
                </label><br>
                <label>Repaired: 
                    <select id="editRepaired">
                        <option>Fixed</option>
                        <option>Not Fixed</option>
                        <option>N/A</option>
                    </select>
                </label><br>
                <label>Notes: <textarea id="editNotes"></textarea></label><br>
                <label>Machine Notes: <textarea id="editMachineNotes"></textarea></label><br>
                <button type="submit">Save Changes</button>
            </form>
        </div>
    </div>

    <script>
        let appData = {
            "data": {},
            "dates": [],
            "currentDay": ""
        };
        let filteredData = [];

        // Load data from local storage
        function loadFromLocalStorage() {
            const savedData = localStorage.getItem('machineHeadData');
            if (savedData) {
                appData = JSON.parse(savedData);
            }
        }

        // Save data to local storage
        function saveToLocalStorage() {
            localStorage.setItem('machineHeadData', JSON.stringify(appData));
        }

        // Convert flat JSON format (HHDBMay2025.json) to appData structure
        function convertFlatJsonToAppData(flatData) {
            const newData = { data: {}, dates: new Set() };

            flatData.forEach(entry => {
                const date = entry.Date;
                const line = entry.Line;
                const head = parseInt(entry.Head, 10) || entry.Head;
                const offline = entry['Offline Status'] || 'Offline';
                const issue = entry.Issue || 'None';
                const repaired = entry.Repaired || 'Not Fixed';
                const notes = entry.Notes || '';

                if (!newData.data[date]) {
                    newData.data[date] = {};
                    newData.dates.add(date);
                }
                if (!newData.data[date][line]) {
                    newData.data[date][line] = { heads: [], machineNotes: '', running: true };
                }
                if (!isNaN(head)) {
                    newData.data[date][line].heads.push({
                        head,
                        offline,
                        issue,
                        repaired,
                        notes
                    });
                }
                if (notes && (notes.includes('RCU') || notes.includes('DMU') || notes.includes('WCU'))) {
                    newData.data[date][line].machineNotes = notes;
                }
            });

            newData.dates = Array.from(newData.dates).sort((a, b) => new Date(a) - new Date(b));
            newData.currentDay = newData.dates[newData.dates.length - 1] || '';
            return newData;
        }

        // Merge new data with existing appData
        function mergeData(newData) {
            newData.dates.forEach(date => {
                if (!appData.dates.includes(date)) {
                    appData.dates.push(date);
                }
            });
            appData.dates.sort((a, b) => new Date(a) - new Date(b));
            appData.currentDay = appData.dates[appData.dates.length - 1] || '';

            Object.keys(newData.data).forEach(date => {
                if (!appData.data[date]) {
                    appData.data[date] = {};
                }
                Object.keys(newData.data[date]).forEach(line => {
                    if (!appData.data[date][line]) {
                        appData.data[date][line] = newData.data[date][line];
                    } else {
                        const existingHeads = appData.data[date][line].heads;
                        const newHeads = newData.data[date][line].heads;
                        newHeads.forEach(newHead => {
                            const existingHead = existingHeads.find(h => h.head === newHead.head);
                            if (!existingHead) {
                                existingHeads.push(newHead);
                            } else {
                                Object.assign(existingHead, newHead);
                            }
                        });
                        existingHeads.sort((a, b) => a.head - b.head);
                        if (newData.data[date][line].machineNotes && newData.data[date][line].machineNotes !== appData.data[date][line].machineNotes) {
                            appData.data[date][line].machineNotes = appData.data[date][line].machineNotes
                                ? `${appData.data[date][line].machineNotes}; ${newData.data[date][line].machineNotes}`
                                : newData.data[date][line].machineNotes;
                        }
                        appData.data[date][line].running = newData.data[date][line].running !== undefined
                            ? newData.data[date][line].running
                            : appData.data[date][line].running;
                    }
                });
            });
        }

        // Process uploaded JSON file
        function processJsonUpload(jsonData) {
            let newData;
            if (jsonData.data && jsonData.dates && jsonData.currentDay) {
                newData = jsonData;
            } else if (Array.isArray(jsonData)) {
                newData = convertFlatJsonToAppData(jsonData);
            } else {
                throw new Error('Unsupported JSON format');
            }
            mergeData(newData);
            return appData;
        }

        function populateFilters() {
            const lines = new Set();
            const heads = new Set();
            const issues = new Set();
            const dates = new Set();

            Object.keys(appData.data).forEach(date => {
                dates.add(date);
                Object.keys(appData.data[date]).forEach(line => {
                    lines.add(line);
                    const lineData = appData.data[date][line];
                    lineData.heads.forEach(head => {
                        if (head.offline === 'Offline') {
                            heads.add(head.head.toString());
                            issues.add(head.issue);
                        }
                    });
                });
            });

            const filterDate = document.getElementById('filterDate');
            filterDate.innerHTML = '<option value="">All Dates</option>';
            Array.from(dates).sort((a, b) => new Date(b) - new Date(a)).forEach(d => {
                const option = document.createElement('option');
                option.value = d;
                option.textContent = d;
                filterDate.appendChild(option);
            });

            const filterLine = document.getElementById('filterLine');
            filterLine.innerHTML = '<option value="">All Lines</option>';
            Array.from(lines).sort().forEach(l => {
                const option = document.createElement('option');
                option.value = l;
                option.textContent = l;
                filterLine.appendChild(option);
            });

            const filterHead = document.getElementById('filterHead');
            filterHead.innerHTML = '<option value="">All Heads</option>';
            Array.from(heads).sort((a, b) => a - b).forEach(h => {
                const option = document.createElement('option');
                option.value = h;
                option.textContent = h;
                filterHead.appendChild(option);
            });

            const filterIssue = document.getElementById('filterIssue');
            filterIssue.innerHTML = '<option value="">All Issues</option>';
            Array.from(issues).sort().forEach(i => {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                filterIssue.appendChild(option);
            });
        }

        function displayOfflineHeads(filtered = false) {
            const tbody = document.getElementById('historyBody');
            tbody.innerHTML = '';
            let displayItems = [];

            for (const date of appData.dates) {
                const dailyData = appData.data[date] || {};
                const lines = Object.keys(dailyData).sort();
                for (const line of lines) {
                    const lineData = dailyData[line];
                    const machineNotes = lineData.machineNotes || '';
                    const offlineHeads = lineData.heads.filter(h => h.offline === 'Offline');

                    offlineHeads.forEach(head => {
                        displayItems.push({ date, line, head: head.head, issue: head.issue, repaired: head.repaired, notes: head.notes, machineNotes: '', type: 'head' });
                    });

                    if (machineNotes.trim() !== '') {
                        displayItems.push({ date, line, head: 'N/A', issue: 'N/A', repaired: 'N/A', notes: 'N/A', machineNotes, type: 'machineNote' });
                    }
                }
            }

            if (filtered) {
                const filterDate = document.getElementById('filterDate').value;
                const filterLine = document.getElementById('filterLine').value;
                const filterHead = document.getElementById('filterHead').value;
                const filterIssue = document.getElementById('filterIssue').value;

                displayItems = displayItems.filter(item => {
                    if (filterDate && item.date !== filterDate) return false;
                    if (filterLine && item.line !== filterLine) return false;
                    if (filterHead && item.head.toString() !== filterHead) return false;
                    if (filterIssue && item.issue !== filterIssue) return false;
                    return true;
                });
            }

            // Sorting
            const sortBy = document.getElementById('sortBy').value;
            const sortOrder = document.getElementById('sortOrder').value === 'Ascending' ? 1 : -1;

            displayItems.sort((a, b) => {
                if (sortBy === 'Date') {
                    return sortOrder * (new Date(b.date) - new Date(a.date));
                } else if (sortBy === 'Line') {
                    return sortOrder * a.line.localeCompare(b.line);
                } else {
                    const dateCompare = new Date(b.date) - new Date(a.date);
                    if (dateCompare !== 0) return sortOrder * dateCompare;
                    return sortOrder * a.line.localeCompare(b.line);
                }
            });

            filteredData = displayItems;

            displayItems.forEach(item => {
                const row = tbody.insertRow();
                row.insertCell().textContent = item.date;
                row.insertCell().textContent = item.line;
                row.insertCell().textContent = item.head;
                row.insertCell().textContent = item.issue;
                row.insertCell().textContent = item.repaired;
                row.insertCell().textContent = item.notes;
                row.insertCell().textContent = item.machineNotes;
                const actionsCell = row.insertCell();
                if (item.type === 'head') {
                    const editBtn = document.createElement('button');
                    editBtn.textContent = 'Edit';
                    editBtn.onclick = () => openEditModal(item.date, item.line, item.head, item);
                    actionsCell.appendChild(editBtn);
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.onclick = () => deleteEntry(item.date, item.line, parseInt(item.head));
                    actionsCell.appendChild(deleteBtn);
                } else if (item.type === 'machineNote') {
                    const editBtn = document.createElement('button');
                    editBtn.textContent = 'Edit';
                    editBtn.onclick = () => openEditModal(item.date, item.line, 'N/A', item);
                    actionsCell.appendChild(editBtn);
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Clear Machine Notes';
                    deleteBtn.onclick = () => clearMachineNotes(item.date, item.line);
                    actionsCell.appendChild(deleteBtn);
                }
            });
        }

        function deleteEntry(date, line, headNum) {
            const lineData = appData.data[date][line];
            lineData.heads = lineData.heads.filter(h => h.head !== headNum);
            if (lineData.heads.length === 0 && !lineData.machineNotes) {
                delete appData.data[date][line];
                if (Object.keys(appData.data[date]).length === 0) {
                    delete appData.data[date];
                    appData.dates = appData.dates.filter(d => d !== date);
                    appData.currentDay = appData.dates[appData.dates.length - 1] || '';
                }
            }
            saveToLocalStorage();
            populateFilters();
            displayOfflineHeads(true);
        }

        function clearMachineNotes(date, line) {
            const lineData = appData.data[date][line];
            lineData.machineNotes = '';
            if (lineData.heads.length === 0) {
                delete appData.data[date][line];
                if (Object.keys(appData.data[date]).length === 0) {
                    delete appData.data[date];
                    appData.dates = appData.dates.filter(d => d !== date);
                    appData.currentDay = appData.dates[appData.dates.length - 1] || '';
                }
            }
            saveToLocalStorage();
            populateFilters();
            displayOfflineHeads(true);
        }

        function openEditModal(date, line, head, item) {
            const modal = document.getElementById('editModal');
            const editForm = document.getElementById('editForm');
            document.getElementById('editLine').value = item.line;
            document.getElementById('editDate').value = item.date;
            document.getElementById('editHead').value = item.head;
            document.getElementById('editOffline').value = item.type === 'head' ? item.offline : 'N/A';
            document.getElementById('editIssue').value = item.issue;
            document.getElementById('editRepaired').value = item.repaired;
            document.getElementById('editNotes').value = item.notes;
            document.getElementById('editMachineNotes').value = item.machineNotes;

            document.getElementById('editHead').disabled = item.type !== 'head';
            document.getElementById('editOffline').disabled = item.type !== 'head';
            document.getElementById('editIssue').disabled = item.type !== 'head';
            document.getElementById('editRepaired').disabled = item.type !== 'head';
            document.getElementById('editNotes').disabled = item.type !== 'head';

            modal.style.display = 'block';

            editForm.onsubmit = (e) => {
                e.preventDefault();
                const newLine = document.getElementById('editLine').value.trim();
                const newDate = document.getElementById('editDate').value;
                const newHead = parseInt(document.getElementById('editHead').value);
                const newOffline = document.getElementById('editOffline').value;
                const newIssue = document.getElementById('editIssue').value;
                const newRepaired = document.getElementById('editRepaired').value;
                const newNotes = document.getElementById('editNotes').value.trim();
                const newMachineNotes = document.getElementById('editMachineNotes').value.trim();

                if (item.type === 'head') {
                    appData.data[date][line].heads = appData.data[date][line].heads.filter(h => h.head !== newHead);
                    if (!appData.data[newDate]) {
                        appData.data[newDate] = {};
                        appData.dates.push(newDate);
                        appData.dates.sort((a, b) => new Date(a) - new Date(b));
                        appData.currentDay = appData.dates[appData.dates.length - 1];
                    }
                    if (!appData.data[newDate][newLine]) {
                        appData.data[newDate][newLine] = { heads: [], machineNotes: '', running: true };
                    }
                    appData.data[newDate][newLine].heads.push({
                        head: newHead,
                        offline: newOffline,
                        issue: newIssue,
                        repaired: newRepaired,
                        notes: newNotes
                    });
                    appData.data[newDate][newLine].heads.sort((a, b) => a.head - b.head);
                }
                appData.data[newDate][newLine].machineNotes = newMachineNotes;

                if (appData.data[date][line].heads.length === 0 && !appData.data[date][line].machineNotes) {
                    delete appData.data[date][line];
                    if (Object.keys(appData.data[date]).length === 0) {
                        delete appData.data[date];
                        appData.dates = appData.dates.filter(d => d !== date);
                        appData.currentDay = appData.dates[appData.dates.length - 1] || '';
                    }
                }

                saveToLocalStorage();
                populateFilters();
                displayOfflineHeads(false); // Show all entries after edit
                modal.style.display = 'none';
            };

            document.querySelector('.close').onclick = () => {
                modal.style.display = 'none';
            };
        }

        document.addEventListener('DOMContentLoaded', () => {
            loadFromLocalStorage();
            displayOfflineHeads();
            populateFilters();
        });

        document.getElementById('jsonUpload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const jsonData = JSON.parse(ev.target.result);
                        processJsonUpload(jsonData);
                        saveToLocalStorage();
                        populateFilters();
                        displayOfflineHeads();
                        alert('Data successfully loaded from JSON file.');
                    } catch (error) {
                        alert('Error processing JSON file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }
        });

        document.getElementById('exportJSON').addEventListener('click', () => {
            const blob = new Blob([JSON.stringify(appData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'machine_data.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        document.getElementById('clearData').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all data?')) {
                appData = { "data": {}, "dates": [], "currentDay": "" };
                saveToLocalStorage();
                populateFilters();
                displayOfflineHeads();
            }
        });

        document.getElementById('addLogForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const line = document.getElementById('addLine').value.trim();
            const date = document.getElementById('addDate').value;
            const headNum = parseInt(document.getElementById('addHead').value);
            const offline = document.getElementById('addOffline').value;
            const issue = document.getElementById('addIssue').value;
            const repaired = document.getElementById('addRepaired').value;
            const notes = document.getElementById('addNotes').value.trim();
            const machineNotes = document.getElementById('addMachineNotes').value.trim();

            if (!appData.data[date]) {
                appData.data[date] = {};
                appData.dates.push(date);
                appData.dates.sort((a, b) => new Date(a) - new Date(b));
                appData.currentDay = appData.dates[appData.dates.length - 1];
            }
            if (!appData.data[date][line]) {
                appData.data[date][line] = { heads: [], machineNotes: '', running: true };
            }
            const existingHead = appData.data[date][line].heads.find(h => h.head === headNum);
            if (existingHead) {
                alert('Head already exists for this line and date. Edit manually if needed.');
                return;
            }
            appData.data[date][line].heads.push({
                head: headNum,
                offline,
                issue,
                repaired,
                notes
            });
            appData.data[date][line].heads.sort((a, b) => a.head - b.head);
            if (machineNotes.trim() !== '') {
                appData.data[date][line].machineNotes = machineNotes;
            }
            console.log('Added entry:', { date, line, head: headNum, offline, issue, repaired, notes, machineNotes });
            saveToLocalStorage();
            populateFilters();
            displayOfflineHeads(false); // Show all entries after adding
        });

        document.getElementById('applyFilters').addEventListener('click', () => {
            displayOfflineHeads(true);
        });

        document.getElementById('exportPDF').addEventListener('click', () => {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            doc.text('Machine Head Offline Database', 14, 10);
            doc.autoTable({
                startY: 20,
                head: [['Date', 'Line', 'Head', 'Issue (Reasoning)', 'Repaired', 'Notes', 'Machine Notes']],
                body: filteredData.map(item => [
                    item.date,
                    item.line,
                    item.head,
                    item.issue,
                    item.repaired,
                    item.notes,
                    item.machineNotes
                ]),
                styles: { fontSize: 8, cellPadding: 2 },
                columnStyles: {
                    0: { cellWidth: 25 }, // Date
                    1: { cellWidth: 20 }, // Line
                    2: { cellWidth: 15 }, // Head
                    3: { cellWidth: 25 }, // Issue
                    4: { cellWidth: 20 }, // Repaired
                    5: { cellWidth: 30 }, // Notes
                    6: { cellWidth: 55 }  // Machine Notes
                },
                didParseCell: (data) => {
                    data.cell.styles.overflow = 'linebreak';
                }
            });
            doc.save('machine_data.pdf');
        });
    </script>
</body>
</html>
