<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Machine Head Database</title>
<style>
        body { font-family: Arial, sans-serif; }
        table { border-collapse: collapse; width: 100%; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        button, input, select, textarea { margin: 10px 0; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: white; margin: 15% auto; padding: 20px; width: 80%; max-width: 500px; }
        .close { float: right; cursor: pointer; }
    </style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
</head>
<body>
<h1>Machine Head Database</h1>
<section>
<h2>Import and Export</h2>
<input accept=".json" id="jsonUpload" type="file"/>
<button id="exportJSON">Export All Data as JSON</button>
<button id="clearData">Clear Database</button>
<button id="exportPDF">Export Filtered Data as PDF</button>
</section>
<section>
<h2>Add to Log</h2>
<form id="addLogForm">
<label>Line: <input id="addLine" required="" type="text"/></label><br/>
<label>Date: <input id="addDate" required="" type="date"/></label><br/>
<label>Head: <input id="addHead" max="14" min="1" required="" type="number"/></label><br/>
<label>Offline Status: 
                <select id="addOffline">

<option>Offline</option>
</select>
</label><br/>
<label>Issue: 
                <select id="addIssue">
<option>None</option>
<option>Operator</option>
<option>Chute</option>
<option>Installed Wrong</option>
<option>Detached Head</option>
<option>Hopper Issues</option>
<option>Stepper Motor Error</option>
<option>Load Cell</option>
<option>Other</option>
</select>
</label><br/>
<label>Repaired: 
                <select id="addRepaired">
<option>Fixed</option>
<option>Not Fixed</option>
<option>N/A</option>
</select>
</label><br/>
<label>Notes: <textarea id="addNotes"></textarea></label><br/>
<label>Machine Notes: <textarea id="addMachineNotes"></textarea></label><br/>
<button type="submit">Add Log Entry</button>
</form>
</section>
<section>
<h2>Filter and View Heads and Machine Notes</h2>
<label>Filter by Date: <select id="filterDate"><option value="">All Dates</option></select></label>
<label>Filter by Line: <select id="filterLine"><option value="">All Lines</option></select></label>
<label>Filter by Head: <select id="filterHead"><option value="">All Heads</option></select></label>
<label>Filter by Issue: <select id="filterIssue"><option value="">All Issues</option></select></label>
<label>Sort by: 
            <select id="sortBy">
<option>Date</option>
<option>Line</option>
<option>Both (Date then Line)</option>
</select>
</label>
<label>Order: 
            <select id="sortOrder">
<option>Descending</option>
<option>Ascending</option>
</select>
</label>
<button id="applyFilters">Apply Filters and Sort</button>
<table>
<thead>
<tr>
<th>Date</th>
<th>Line</th>
<th>Head</th>
<th>Offline Status</th>
<th>Issue (Reasoning)</th>
<th>Repaired</th>
<th>Notes</th>
<th>Machine Notes</th>
<th>Actions</th>
</tr>
</thead>
<tbody id="historyBody"></tbody>
</table>
</section>
<!-- Edit Modal -->
<div class="modal" id="editModal">
<div class="modal-content">
<span class="close">Ã—</span>
<h2>Edit Entry</h2>
<form id="editForm">
<label>Line: <input id="editLine" required="" type="text"/></label><br/>
<label>Date: <input id="editDate" required="" type="date"/></label><br/>
<label>Head: <input id="editHead" max="14" min="1" type="number"/></label><br/>
<label>Offline Status: 
                    <select id="editOffline">

<option>Offline</option>
</select>
</label><br/>
<label>Issue: 
                    <select id="editIssue">
<option>None</option>
<option>Operator</option>
<option>Chute</option>
<option>Installed Wrong</option>
<option>Detached Head</option>
<option>Hopper Issues</option>
<option>Stepper Motor Error</option>
<option>Load Cell</option>
<option>Other</option>
</select>
</label><br/>
<label>Repaired: 
                    <select id="editRepaired">
<option>Fixed</option>
<option>Not Fixed</option>
<option>N/A</option>
</select>
</label><br/>
<label>Notes: <textarea id="editNotes"></textarea></label><br/>
<label>Machine Notes: <textarea id="editMachineNotes"></textarea></label><br/>
<button type="submit">Save Changes</button>
</form>
</div>
</div>
<script>
        let appData = {
            "data": {},
            "dates": [],
            "currentDay": ""
        };
        let filteredData = [];

        // Load data from local storage
        function loadFromLocalStorage() {
            const savedData = localStorage.getItem('machineHeadData');
            if (savedData) {
                appData = JSON.parse(savedData);
            }
        }

        // Save data to local storage
        function saveToLocalStorage() {
            localStorage.setItem('machineHeadData', JSON.stringify(appData));
        }

        // Convert flat JSON format (HHDBMay2025.json) to appData structure
        function convertFlatJsonToAppData(flatData) {
            const newData = { data: {}, dates: new Set() };

            flatData.forEach(entry => {
                const date = entry.Date;
                const line = entry.Line;
                const head = parseInt(entry.Head, 10) || entry.Head;
                const offline = entry['Offline Status'] || 'Offline';
                const issue = entry.Issue || 'None';
                const repaired = entry.Repaired || 'Not Fixed';
                const notes = entry.Notes || '';

                if (!newData.data[date]) {
                    newData.data[date] = {};
                    newData.dates.add(date);
                }
                if (!newData.data[date][line]) {
                    newData.data[date][line] = { heads: [], machineNotes: '', running: true };
                }
                if (!isNaN(head)) {
                    newData.data[date][line].heads.push({
                        head,
                        offline,
                        issue,
                        repaired,
                        notes
                    });
                }
                if (notes && (notes.includes('RCU') || notes.includes('DMU') || notes.includes('WCU'))) {
                    newData.data[date][line].machineNotes = notes;
                }
            });

            newData.dates = Array.from(newData.dates).sort((a, b) => new Date(a) - new Date(b));
            newData.currentDay = newData.dates[newData.dates.length - 1] || '';
            return newData;
        }

        // Merge new data with existing appData
        function mergeData(newData) {
            newData.dates.forEach(date => {
                if (!appData.dates.includes(date)) {
                    appData.dates.push(date);
                }
            });
            appData.dates.sort((a, b) => new Date(a) - new Date(b));
            appData.currentDay = appData.dates[appData.dates.length - 1] || '';

            Object.keys(newData.data).forEach(date => {
                if (!appData.data[date]) {
                    appData.data[date] = {};
                }
                Object.keys(newData.data[date]).forEach(line => {
                    if (!appData.data[date][line]) {
                        appData.data[date][line] = newData.data[date][line];
                    } else {
                        const existingHeads = appData.data[date][line].heads;
                        const newHeads = newData.data[date][line].heads;
                        newHeads.forEach(newHead => {
                            const existingHead = existingHeads.find(h => h.head === newHead.head);
                            if (!existingHead) {
                                existingHeads.push(newHead);
                            } else {
                                Object.assign(existingHead, newHead);
                            }
                        });
                        existingHeads.sort((a, b) => a.head - b.head);
                        if (newData.data[date][line].machineNotes && newData.data[date][line].machineNotes !== appData.data[date][line].machineNotes) {
                            appData.data[date][line].machineNotes = appData.data[date][line].machineNotes
                                ? `${appData.data[date][line].machineNotes}; ${newData.data[date][line].machineNotes}`
                                : newData.data[date][line].machineNotes;
                        }
                        appData.data[date][line].running = newData.data[date][line].running !== undefined
                            ? newData.data[date][line].running
                            : appData.data[date][line].running;
                    }
                });
            });
        }

        // Process uploaded JSON file
        function processJsonUpload(jsonData) {
            let newData;
            if (jsonData.data && jsonData.dates && jsonData.currentDay) {
                newData = jsonData;
            } else if (Array.isArray(jsonData)) {
                newData = convertFlatJsonToAppData(jsonData);
            } else {
                throw new Error('Unsupported JSON format');
            }
            mergeData(newData);
            return appData;
        }

        function populateFilters() {
            const lines = new Set();
            const heads = new Set();
            const issues = new Set();
            const dates = new Set();

            Object.keys(appData.data).forEach(date => {
                dates.add(date);
                Object.keys(appData.data[date]).forEach(line => {
                    lines.add(line);
                    const lineData = appData.data[date][line];
                    lineData.heads.forEach(head => {
                        heads.add(head.head.toString());
                        issues.add(head.issue);
                    });
                });
            });

            const filterDate = document.getElementById('filterDate');
            filterDate.innerHTML = '<option value="">All Dates</option>';
            Array.from(dates).sort((a, b) => new Date(b) - new Date(a)).forEach(d => {
                const option = document.createElement('option');
                option.value = d;
                option.textContent = d;
                filterDate.appendChild(option);
            });

            const filterLine = document.getElementById('filterLine');
            filterLine.innerHTML = '<option value="">All Lines</option>';
            Array.from(lines).sort().forEach(l => {
                const option = document.createElement('option');
                option.value = l;
                option.textContent = l;
                filterLine.appendChild(option);
            });

            const filterHead = document.getElementById('filterHead');
            filterHead.innerHTML = '<option value="">All Heads</option>';
            Array.from(heads).sort((a, b) => a - b).forEach(h => {
                const option = document.createElement('option');
                option.value = h;
                option.textContent = h;
                filterHead.appendChild(option);
            });

            const filterIssue = document.getElementById('filterIssue');
            filterIssue.innerHTML = '<option value="">All Issues</option>';
            Array.from(issues).sort().forEach(i => {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                filterIssue.appendChild(option);
            });
        }

        function displayOfflineHeads(filtered = false) {
            const tbody = document.getElementById('historyBody');
            tbody.innerHTML = '';
            let displayItems = [];

            const dates = appData.dates.slice().sort((a, b) => new Date(b) - new Date(a)); // Latest to oldest
            for (const date of dates) {
                const dailyData = appData.data[date] || {};
                const lines = Object.keys(dailyData).sort();
                for (const line of lines) {
                    const lineData = dailyData[line];
                    const machineNotes = lineData.machineNotes || '';
                    const heads = lineData.heads || [];

                    heads.forEach(head => {
                        if (head.offline.toLowerCase() !== 'active') { displayItems.push({ date, line, head: head.head, offline: head.offline, issue: head.issue, repaired: head.repaired, notes: head.notes, machineNotes: '', type: 'head' }); }
                    });

                    if (machineNotes.trim() !== '') {
                        displayItems.push({ date, line, head: 'N/A', issue: 'N/A', repaired: 'N/A', notes: 'N/A', machineNotes, type: 'machineNote' });
                    }
                }
            }

            if (filtered) {
                const filterDate = document.getElementById('filterDate').value;
                const filterLine = document.getElementById('filterLine').value;
                const filterHead = document.getElementById('filterHead').value;
                const filterIssue = document.getElementById('filterIssue').value;

                displayItems = displayItems.filter(item => {
                    if (filterDate && item.date !== filterDate) return false;
                    if (filterLine && item.line !== filterLine) return false;
                    if (filterHead && item.head.toString() !== filterHead) return false;
                    if (filterIssue && item.issue !== filterIssue) return false;
                    return true;
                });
            }

            // Sorting
            const sortBy = document.getElementById('sortBy').value;
            const sortOrder = document.getElementById('sortOrder').value === 'Ascending' ? 1 : -1;

            displayItems.sort((a, b) => {
                if (sortBy === 'Date') {
                    return sortOrder * (new Date(b.date) - new Date(a.date));
                } else if (sortBy === 'Line') {
                    return sortOrder * a.line.localeCompare(b.line);
                } else {
                    const dateCompare = new Date(b.date) - new Date(a.date);
                    if (dateCompare !== 0) return sortOrder * dateCompare;
                    return sortOrder * a.line.localeCompare(b.line);
                }
            });

            filteredData = displayItems;

            displayItems.forEach(item => {
                const row = tbody.insertRow();
                row.insertCell().textContent = item.date;
                row.insertCell().textContent = item.line;
                row.insertCell().textContent = item.head;
                row.insertCell().textContent = item.offline;
                row.insertCell().textContent = item.issue;
                row.insertCell().textContent = item.repaired;
                row.insertCell().textContent = item.notes;
                row.insertCell().textContent = item.machineNotes;
                const actionsCell = row.insertCell();
                if (item.type === 'head') {
                    const editBtn = document.createElement('button');
                    editBtn.textContent = 'Edit';
                    editBtn.onclick = () => openEditModal(item.date, item.line, item.head, item);
                    actionsCell.appendChild(editBtn);
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.onclick = () => deleteEntry(item.date, item.line, item.head);
                    actionsCell.appendChild(deleteBtn);
                } else if (item.type === 'machineNote') {
                    const editBtn = document.createElement('button');
                    editBtn.textContent = 'Edit';
                    editBtn.onclick = () => openEditModal(item.date, item.line, 'N/A', item);
                    actionsCell.appendChild(editBtn);
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Clear Machine Notes';
                    deleteBtn.onclick = () => clearMachineNotes(item.date, item.line);
                    actionsCell.appendChild(deleteBtn);
                }
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            loadFromLocalStorage();
            displayOfflineHeads(false);
            populateFilters();
        });

        document.getElementById('jsonUpload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const jsonData = JSON.parse(ev.target.result);
                        processJsonUpload(jsonData);
                        saveToLocalStorage();
                        populateFilters();
                        displayOfflineHeads(false);
                        alert('Data successfully loaded from JSON file.');
                    } catch (error) {
                        alert('Error processing JSON file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }
        });

        document.getElementById('exportJSON').addEventListener('click', () => {
            const blob = new Blob([JSON.stringify(appData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'machine_data.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        document.getElementById('clearData').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all data?')) {
                appData = { "data": {}, "dates": [], "currentDay": "" };
                saveToLocalStorage();
                populateFilters();
                displayOfflineHeads(false);
            }
        });

        document.getElementById('addLogForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const line = document.getElementById('addLine').value.trim();
            const date = document.getElementById('addDate').value;
            const headNum = parseInt(document.getElementById('addHead').value);
            const offline = document.getElementById('addOffline').value;
            const issue = document.getElementById('addIssue').value;
            const repaired = document.getElementById('addRepaired').value;
            const notes = document.getElementById('addNotes').value.trim();
            const machineNotes = document.getElementById('addMachineNotes').value.trim();

            if (!appData.data[date]) {
                appData.data[date] = {};
                appData.dates.push(date);
                appData.dates.sort((a, b) => new Date(a) - new Date(b));
                appData.currentDay = appData.dates[appData.dates.length - 1];
            }
            if (!appData.data[date][line]) {
                appData.data[date][line] = { heads: [], machineNotes: '', running: true };
            }
            const existingHead = appData.data[date][line].heads.find(h => h.head === headNum);
            if (existingHead) {
                alert('Head already exists for this line and date. Edit manually if needed.');
                return;
            }
            appData.data[date][line].heads.push({
                head: headNum,
                offline,
                issue,
                repaired,
                notes
            });
            appData.data[date][line].heads.sort((a, b) => a.head - b.head);
            if (machineNotes.trim() !== '') {
                appData.data[date][line].machineNotes = machineNotes;
            }
            saveToLocalStorage();
            populateFilters();
            displayOfflineHeads(false); // Show all to ensure new entry is visible
        });

        document.getElementById('applyFilters').addEventListener('click', () => {
            displayOfflineHeads(true);
        });

        document.getElementById('exportPDF').addEventListener('click', () => {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            doc.text('Machine Head Database', 14, 10);
            doc.autoTable({
                startY: 20,
                head: [['Date', 'Line', 'Head', 'Offline Status', 'Issue (Reasoning)', 'Repaired', 'Notes', 'Machine Notes']],
                body: filteredData.map(item => [
                    item.date,
                    item.line,
                    item.head,
                    item.offline,
                    item.issue,
                    item.repaired,
                    item.notes,
                    item.machineNotes
                ]),
                styles: { fontSize: 8, cellPadding: 2 },
                columnStyles: {
                    0: { cellWidth: 20 }, // Date
                    1: { cellWidth: 15 }, // Line
                    2: { cellWidth: 10 }, // Head
                    3: { cellWidth: 20 }, // Offline Status
                    4: { cellWidth: 25 }, // Issue
                    5: { cellWidth: 20 }, // Repaired
                    6: { cellWidth: 30 }, // Notes
                    7: { cellWidth: 55 }  // Machine Notes
                },
                didParseCell: (data) => {
                    data.cell.styles.overflow = 'linebreak';
                }
            });
            doc.save('machine_data.pdf');
        });
    </script>
</body>
</html>
